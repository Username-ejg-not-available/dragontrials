import Automata as a
def statePermutations(length: int):
    res = [[]]
    for x in range(length):
        nres = []
        for y in range(len(res)):
            nres += [res[y] + [x]]
        res += nres
    return res[1:]

def statePermutations2(length: int):
    res = { 'temp': [] }
    count = 0
    for x in range(length):
        nres = {}
        for y in res:
            nres.update({ count: res[y] + [x] })
            count += 1
        res = {**res, **nres}
    del res['temp']
    return res

def toDFA(nfa: a.NFA):
    # get state permutations
    Q = statePermutations(len(nfa.deltaT))
    # remove epsilon from sigma
    res = a.NFA(' ')
    res.sigma = nfa.sigma[:len(nfa.sigma) - 1]
    res.deltaT = [[] for st in Q]
    res.startState = Q.index([res.startState])
    res.finStates = []

    # this is the unioning stuff, just treats each permutation as a state name, then goes through it to see
    # what makes up that state
    for st in range(len(Q)):
        for l in range(len(res.sigma)):
            next = []
            for oldSt in Q[st]:
                for x in nfa.deltaT[oldSt][l]:
                    if x not in next:
                        next.append(x)
            res.deltaT[st].append(sorted(next))
    # renames the states from the permutation to something less ugly
    for st in range(len(res.deltaT)):
        for l in range(len(res.sigma)):
            for uglySt in Q:
                if res.deltaT[st][l] == uglySt:
                    res.deltaT[st][l] = [Q.index(uglySt)]
                    break
                for fst in nfa.finStates:
                    if fst in uglySt and Q.index(uglySt) not in res.finStates:
                        res.finStates.append(Q.index(uglySt))
    return a.reduce(res)

def toDFA2(nfa: a.NFA):
    Q = statePermutations2(len(nfa.deltaT))
    res = a.NFA(' ')
    res.sigma = nfa.sigma[:len(nfa.sigma) - 1]
    res.deltaT = [[] for st in Q]
    res.startState = Q[nfa.startState]
    res.finStates = []
    #this version doesn't yet handle final states
    for st in Q:
        for l in range(len(res.sigma)):
            next = []
            for oldSt in Q[st]:
                for x in nfa.deltaT[oldSt][l]:
                    if x not in next:
                        next.append(x)
            next.sort()
            for x in Q:
                if Q[x] == next:
                    res.deltaT[st].append([x])
                    break
            else: res.deltaT[st].append([])
    
    return a.reduce(res)
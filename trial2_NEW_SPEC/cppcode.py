token = ''.join(["struct Token {",
	"\n\tenum class Type {",
	"\n\t\tTERMINAL,",
	"\n\t\tNONTERMINAL,",
	"\n\t\tACTION",
	"\n\t};"
	"\n\tstd::string symbol;",
	"\n\tstd::string lexeme;",
	"\n\tType type;"
	"\n\tint l, c;",
	"\n\t//Token from input token stream",
	"\n\tToken(std::string n1, std::string n2) : symbol(""), lexeme(""), type(Type::TERMINAL),l(-1),c(-1) {",
	"\n\t\tint t = 0;",
	"\n\t\twhile (n1.size()) {",
	"\n\t\t\tif (!t) {",
	"\n\t\t\t\tif (n1 != \"\" && n1[0] != ':') {",
	"\n\t\t\t\t\tsymbol += n1[0];",
	"\n\t\t\t\t\tn1 = n1.substr(1);",
	"\n\t\t\t\t} else if (n1[0] == ':') {",
	"\n\t\t\t\t\tt = 1;",
	"\n\t\t\t\t\tn1 = n1.substr(1);",
	"\n\t\t\t\t} else break;",
	"\n\t\t\t}",
	"\n\t\t\telse if (t == 1) {",
	"\n\t\t\t\tif (n1 != \"\") {",
	"\n\t\t\t\t\tlexeme += n1[0];",
	"\n\t\t\t\t\tn1 = n1.substr(1);",
	"\n\t\t\t\t} else break;",
	"\n\t\t\t}",
	"\n\t\t}",
	"\n\t\tstd::string temp;",
	"\n\t\tn2 = n2.substr(1);",
	"\n\t\twhile (n2[0] != ',') {",
	"\n\t\t\ttemp += n2[0];",
	"\n\t\t\tn2 = n2.substr(1);",
	"\n\t\t}",
	"\n\t\tn2 = n2.substr(1);",
	"\n\t\tl = std::atoi(temp.c_str());",
	"\n\t\ttemp = \"\";",
	"\n\t\twhile (n2[0] != ']') {",
	"\n\t\t\ttemp += n2[0];",
	"\n\t\t\tn2 = n2.substr(1);",
	"\n\t\t}",
	"\n\t\tc = std::atoi(temp.c_str());"
	"\n\t}",
	"\n\t//Token generated by parser to put in stack",
	"\n\tToken(std::string line) : symbol(), lexeme(), type(Type::TERMINAL), l(-1), c(-1) {",
	"\n\t\tif (line[0] == '#') {",
	"\n\t\t\ttype = Type::ACTION;",
	"\n\t\t\tsymbol = line.substr(1);",
	"\n\t\t} else if (std::count(nonterms.begin(),nonterms.end(),line)) {",
	"\n\t\t\ttype = Type::NONTERMINAL;",
	"\n\t\t\tsymbol = line;",
	"\n\t\t} else {",
	"\n\t\t\tsymbol = line;",
	"\n\t\t}",
	"\n\t}"
    "\n};\n\n"])

def selectable(table): 
	out = "//Converting my pretty Python maps to C++ is Distgusting but must be done bc my old trial 2 was all in python\n"
	out += "using STable = std::map<std::string,std::map<std::string,std::vector<std::string>>>;\nSTable* s = nullptr;\n"
	out += "static STable* getTable() {\n\tif (s != nullptr) return s;\n"
	out += "\ts = new STable();\n"
	for n in table:
		if n == '\x19': rn = '\"\\31\"'
		else: rn = '\"' + n + '\"'
		out += "\ts->insert(std::pair<std::string,std::map<std::string,std::vector<std::string>>>(" + rn
		out += ",std::map<std::string,std::vector<std::string>>()));\n"
		for ps in table[n]:
			if ps == '\x18': rt = '\"\\30\"'
			else: rt = '\"' + ps + '\"'
			out += "\t(*s)[" + rn + '].insert(std::pair<std::string,std::vector<std::string>>(' + rt
			out += ',std::vector<std::string>()));\n'
			if table[n][ps] != None:
				if table[n][ps] == []:
					out += "\t(*s)["+rn+"]["+rt+"].push_back(\"\");\n"
				else:
					for z in table[n][ps]:
						if z == '\x18': out += "\t(*s)["+rn+"]["+rt+"].push_back(\"\\30\");\n"
						else: out += "\t(*s)["+rn+"]["+rt+"].push_back(\""+z+"\");\n"
	t = False
	for n in table:
		if n == '\x19': rn = '\"\\31\"'
		else: rn = '\"' + n + '\"'
		out += "\tnonterms.push_back("+rn+");\n"
		if not t:
			t = True
			for ps in table[n]:
				if ps == '\x18': rt = '\"\\30\"'
				else: rt = '\"' + ps + '\"'
				out += "\tterms.push_back("+rt+");\n"
	out += "\treturn s;\n}\n\n"
	return out

llparser = ''.join([
	"std::vector<Token> tks;\n",
	"class LL1Parser {\n",
	"private:\n",
	"\tstd::stack<Token> stack;\n",
	"public:\n",
	"\tLL1Parser(){ stack.push(Token(\"\\31\")); }\n",
	"\t~LL1Parser() { }\n"
	"\tbool parse() {\n",
	"\t\twhile (stack.size()) {\n",
	"\t\t\tif (stack.top().type == Token::Type::TERMINAL) {\n",
	"\t\t\t\tif (stack.top().symbol == tks.at(lookahead).symbol) {\n",
	"\t\t\t\t\tlookahead++;\n",
	"\t\t\t\t\tif ((long unsigned int)lookahead < tks.size())\n",
	"\t\t\t\t\t\tlook = tks.at(lookahead).lexeme.c_str();\n",
	"\t\t\t\t\tstack.pop();\n",
	"\t\t\t\t} else return false;\n",
	"\t\t\t} else if (stack.top().type == Token::Type::NONTERMINAL) {\n",
	"\t\t\t\tToken val = stack.top();\n",
	"\t\t\t\tstack.pop();\n",
	"\t\t\t\tstd::vector<std::string> prod = (*getTable())[val.symbol][tks[lookahead].symbol];\n",
	"\t\t\t\tif (prod.size()) {\n",
	"\t\t\t\t\tfor (int i = prod.size() - 1; i > -1 && prod.at(0) != \"\"; i--) {\n",
	"\t\t\t\t\t\tstack.push(Token(prod[i]));\n",
	"\t\t\t\t\t}\n",
	"\t\t\t\t} else return false;\n",
	"\t\t\t} else {\n",
	"\t\t\t\trunActions(std::atoi(stack.top().symbol.c_str()));\n",
	"\t\t\t\tstack.pop();\n",
	"\t\t\t}\n",
	"\t\t}\n",
	"\t\treturn true;\n",
	"\t}\n",
	"};\n\n"
])

cmain = ''.join([
	"int main(int argc, char** argv) {\n",
	"\tif (argc < 2) {\n",
	"\t\tstd::cout << \"Format: ./translator <.tokens>\\n\";\n",
	"\t\treturn 1;\n",
	"\t}\n",
	"\tSTable* lltable = getTable();\n",
	"\tLL1Parser* parser = new LL1Parser();\n"
	"\tstd::ifstream tkstream(argv[1]);\n",
	"\tstd::string in1,in2;\n"
	"\twhile (tkstream >> in1 >> in2) tks.push_back(Token(in1,in2));\n",
	"\ttkstream.close();\n",
	"\tif (tks.at(tks.size() - 1).symbol != \"\\30\") {\n",
	"\t\tint l = tks.at(tks.size() - 1).l + 1;\n"
	"\t\ttks.push_back(Token(\"\\30\",\"[\"+std::to_string(l)+\",1]\"));\n",
	"\t}\n",
	"\tlook = tks.at(0).lexeme.c_str();\n",
	"\tif (parser->parse()) std::cout << \"accepted\\n\";\n",
	"\telse {\n",
	"\t\tstd::cout << \"rejected\\n\";\n",
	"\t\treturn 1;\n",
	"\t}\n",
	"\tdelete lltable;\n",
	"\tdelete parser;\n",
	"}"
])